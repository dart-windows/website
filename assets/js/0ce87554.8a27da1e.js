"use strict";(self.webpackChunkwin_32_site=self.webpackChunkwin_32_site||[]).push([[578],{3905:(e,n,t)=>{t.d(n,{Zo:()=>m,kt:()=>u});var a=t(7294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var s=a.createContext({}),p=function(e){var n=a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},m=function(e){var n=p(e.components);return a.createElement(s.Provider,{value:n},e.children)},c="mdxType",d={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},h=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,m=l(e,["components","mdxType","originalType","parentName"]),c=p(t),h=r,u=c["".concat(s,".").concat(h)]||c[h]||d[h]||i;return t?a.createElement(u,o(o({ref:n},m),{},{components:t})):a.createElement(u,o({ref:n},m))}));function u(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var i=t.length,o=new Array(i);o[0]=h;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=e,l[c]="string"==typeof e?e:r,o[1]=l;for(var p=2;p<i;p++)o[p]=t[p];return a.createElement.apply(null,o)}return a.createElement.apply(null,t)}h.displayName="MDXCreateElement"},2340:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>o,default:()=>d,frontMatter:()=>i,metadata:()=>l,toc:()=>p});var a=t(7462),r=(t(7294),t(3905));const i={sidebar_position:5},o="Managing memory",l={unversionedId:"win32-programming/memory",id:"win32-programming/memory",title:"Managing memory",description:"Dart is a garbage-collected language. When you create objects (e.g. allocating a",source:"@site/docs/win32-programming/memory.md",sourceDirName:"win32-programming",slug:"/win32-programming/memory",permalink:"/docs/win32-programming/memory",draft:!1,editUrl:"https://github.com/dart-windows/website/tree/main/docs/win32-programming/memory.md",tags:[],version:"current",sidebarPosition:5,frontMatter:{sidebar_position:5},sidebar:"win32DocSidebar",previous:{title:"Using Win32 structs from Dart",permalink:"/docs/win32-programming/structs"},next:{title:"COM Programming",permalink:"/docs/category/com-programming"}},s={},p=[{value:"Allocating memory with Dart",id:"allocating-memory-with-dart",level:2},{value:"Allocating strings",id:"allocating-strings",level:2},{value:"Patterns for freeing memory allocations",id:"patterns-for-freeing-memory-allocations",level:2},{value:"The <code>try</code>/<code>finally</code> pattern",id:"the-tryfinally-pattern",level:3},{value:"The <code>using</code> pattern",id:"the-using-pattern",level:3}],m={toc:p},c="wrapper";function d(e){let{components:n,...t}=e;return(0,r.kt)(c,(0,a.Z)({},m,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"managing-memory"},"Managing memory"),(0,r.kt)("p",null,"Dart is a garbage-collected language. When you create objects (e.g. allocating a\nstring to a variable, or instantiating a class), Dart is responsible for\nallocating memory for them, as well ensuring that the memory used is freed when\nthose objects are no longer in use."),(0,r.kt)("p",null,"However, when you're working with libraries through FFI, only primitive values\n(such as integers) can be passed directly through to the native code being\ncalled. For other types, such as strings and data structures, you have to take\nresponsibility for allocating memory from the heap and freeing it up when it is\nno longer used."),(0,r.kt)("h2",{id:"allocating-memory-with-dart"},"Allocating memory with Dart"),(0,r.kt)("p",null,"So how do you allocate memory a block of memory for use with Windows? The\nsimplest approach is to use the ",(0,r.kt)("inlineCode",{parentName:"p"},"calloc()")," function in ",(0,r.kt)("inlineCode",{parentName:"p"},"package:ffi"),", which\ncalls the underlying Windows API to allocate and zero out memory from the heap.\nFor example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-dart"},"final pBuffer = calloc<Uint8>(256);\n")),(0,r.kt)("p",null,"This snippet allocates 256 bytes and returns a ",(0,r.kt)("inlineCode",{parentName:"p"},"Pointer<Uint8>")," object, which\ncan be used to manage the memory. You can use ",(0,r.kt)("inlineCode",{parentName:"p"},"pBuffer")," with an indexed array\noperator to access the allocated memory, for example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-dart"},"for (var i=0; i<256; i++) {\n  pBuffer[i] = i % 8;\n}\n")),(0,r.kt)("p",null,"which fills the allocated memory with a repeated range of ",(0,r.kt)("inlineCode",{parentName:"p"},"[0..8]"),"."),(0,r.kt)("admonition",{type:"danger"},(0,r.kt)("p",{parentName:"admonition"},"Be careful to only access memory that you have allocated. The results of reading\nor writing unallocated memory are non-deterministic, but include an immediate\ncrash of your application or even data corruption.")),(0,r.kt)("p",null,"When you have completed the operation for which the allocated memory was needed,\nyou should release it so that it can be reused. ",(0,r.kt)("inlineCode",{parentName:"p"},"dart:ffi")," provides a\n",(0,r.kt)("a",{parentName:"p",href:"https://api.dart.dev/stable/3.0.0/dart-ffi/Allocator/free.html"},(0,r.kt)("inlineCode",{parentName:"a"},"calloc.free()")),"\nmethod, but for convenience, ",(0,r.kt)("inlineCode",{parentName:"p"},"package:win32")," provides a simple ",(0,r.kt)("inlineCode",{parentName:"p"},"free()")," global\nfunction, which you can use as follows:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-dart"},"free(pBuffer);\n")),(0,r.kt)("p",null,"When your Dart program exits, Windows will automatically free all allocated\nmemory that hasn't previously been released, but you shouldn't depend on that.\nIn the absence of any other garbage collection for native memory, long-running\napplications that don't release manually-allocated memory will gradually exhaust\nthe available heap space (this is known as \"leaking\" memory)."),(0,r.kt)("h2",{id:"allocating-strings"},"Allocating strings"),(0,r.kt)("p",null,"Win32 APIs as projected by Dart typically assume a 16-bit Unicode encoding,\nwhere each character is represented by 2 bytes. The Dart FFI package makes it\neasy to copy a Dart-allocated String to native memory, where it can be passed to\nWin32 APIs:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-dart"},"final verb = 'open'.toNativeUtf16();\nfinal process = 'notepad.exe'.toNativeUtf16();\nShellExecute(0, verb, process, nullptr, nullptr, SW_SHOW);\n\n// Do something\n\nfree(verb);\nfree(process);\n")),(0,r.kt)("p",null,"In this example, ",(0,r.kt)("inlineCode",{parentName:"p"},"verb")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"process")," are of type ",(0,r.kt)("inlineCode",{parentName:"p"},"Pointer<Utf16>"),", which\nrepresents a pointer to native memory. The allocated memory includes two bytes\nfor every character in ",(0,r.kt)("inlineCode",{parentName:"p"},"dartText"),", plus a final null-termination character\n(",(0,r.kt)("inlineCode",{parentName:"p"},"\\x00"),")."),(0,r.kt)("admonition",{type:"caution"},(0,r.kt)("p",{parentName:"admonition"},"Behind the scenes, the ",(0,r.kt)("inlineCode",{parentName:"p"},".toNativeUtf16()")," method allocates memory using the same\nunderlying functions as the ",(0,r.kt)("inlineCode",{parentName:"p"},"calloc()")," method above, so you are still\nresponsible for freeing its memory.")),(0,r.kt)("p",null,"If you want to create a new string, Win32 provides a simple function ",(0,r.kt)("inlineCode",{parentName:"p"},"wsalloc"),",\nwhich allocates the necessary storage. This is particularly useful when you wish\nto ",(0,r.kt)("em",{parentName:"p"},"receive")," a string from Windows. The following example calls the Win32\n",(0,r.kt)("a",{parentName:"p",href:"https://learn.microsoft.com/en-us/windows/win32/api/shlobj_core/nf-shlobj_core-shgetfolderpathw"},(0,r.kt)("inlineCode",{parentName:"a"},"SHGetFolderPath")),"\nAPI to retrieve the directory of the Desktop folder:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-dart"},"final path = wsalloc(MAX_PATH);\nSHGetFolderPath(NULL, CSIDL_DESKTOP, NULL, 0, path);\nprint('The Windows desktop folder is at ${path.toDartString()}');\nfree(path);\n")),(0,r.kt)("p",null,"In the example above, the returned value is converted back to a Dart string\nusing the ",(0,r.kt)("inlineCode",{parentName:"p"},".toDartString()")," extension method on ",(0,r.kt)("inlineCode",{parentName:"p"},"Pointer<Utf16>"),"."),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("p",{parentName:"admonition"},"Calling ",(0,r.kt)("inlineCode",{parentName:"p"},".toString()")," on ",(0,r.kt)("inlineCode",{parentName:"p"},"path")," won't give the results you might expect, since\n",(0,r.kt)("inlineCode",{parentName:"p"},"path")," is of type ",(0,r.kt)("inlineCode",{parentName:"p"},"Pointer<Utf16>"),". Instead it will print the address of the\npointer, something like this:"),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-terminal"},"Pointer: address=0x1729cc18240\n"))),(0,r.kt)("h2",{id:"patterns-for-freeing-memory-allocations"},"Patterns for freeing memory allocations"),(0,r.kt)("p",null,"Consider the following (bad) example of a function that calls\n",(0,r.kt)("a",{parentName:"p",href:"https://learn.microsoft.com/en-us/windows/win32/api/combaseapi/nf-combaseapi-cocreateguid"},(0,r.kt)("inlineCode",{parentName:"a"},"CoCreateGuid")),"\nto return a String. Can you see a potential bug in this code?"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-dart"},"// BAD: Don't do this, since the memory for pGuid may not be released\nString createGUID() {\n  final pGuid = calloc<GUID>();\n\n  final hr = CoCreateGuid(pGuid);\n  if (FAILED(hr)) throw WindowsException(hr);\n  final guid = pGuid.ref.toString();\n  free(pGuid);\n  return guid;\n}\n")),(0,r.kt)("p",null,"Here's the problem: if ",(0,r.kt)("inlineCode",{parentName:"p"},"CoCreateGuid()")," fails, ",(0,r.kt)("inlineCode",{parentName:"p"},"pGuid")," will not be released\nprior to the exception being thrown. In this example, there are simple solutions\n(e.g. call ",(0,r.kt)("inlineCode",{parentName:"p"},"free")," in both failure and success scenarios). But when you're\nallocating lots of different objects, this approach can result in rather\nunreadable code with plenty of opportunity for memory leaks."),(0,r.kt)("h3",{id:"the-tryfinally-pattern"},"The ",(0,r.kt)("inlineCode",{parentName:"h3"},"try"),"/",(0,r.kt)("inlineCode",{parentName:"h3"},"finally")," pattern"),(0,r.kt)("p",null,"One good approach is the ",(0,r.kt)("inlineCode",{parentName:"p"},"try"),"/",(0,r.kt)("inlineCode",{parentName:"p"},"finally")," pattern in Dart, which guarantees the\n",(0,r.kt)("inlineCode",{parentName:"p"},"finally")," clause will be called:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-dart"},"// GOOD: This approach is safe and convenient.\nString createGUID() {\n  final pGuid = calloc<GUID>();\n  try {\n    final hr = CoCreateGuid(pGuid);\n    if (FAILED(hr)) throw WindowsException(hr);\n    return pGuid.ref.toString();\n  } finally {\n    free(pGuid);\n  }\n}\n")),(0,r.kt)("p",null,"In the above example, the ",(0,r.kt)("inlineCode",{parentName:"p"},"free")," will get called regardless of whether\n",(0,r.kt)("inlineCode",{parentName:"p"},"CoCreateGuid()")," fails or not. And there's no need to allocate the result to a\nseparate string before returning, since we know that ",(0,r.kt)("inlineCode",{parentName:"p"},"finally")," will be called at\nthe appropriate time."),(0,r.kt)("h3",{id:"the-using-pattern"},"The ",(0,r.kt)("inlineCode",{parentName:"h3"},"using")," pattern"),(0,r.kt)("p",null,"For simpler methods, the ",(0,r.kt)("inlineCode",{parentName:"p"},"try"),"/",(0,r.kt)("inlineCode",{parentName:"p"},"finally")," pattern works well. But as you add more\nmanually-allocated objects, this becomes more unwieldy. For example, consider\nthis function, which interrogates Windows for the timestamp when the currently-running process was created:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-dart"},"DateTime processCreationTime() {\n  final hProcess = GetCurrentProcess();\n  final pCreationTime = calloc<FILETIME>();\n  final pExitTime = calloc<FILETIME>();\n  final pKernelTime = calloc<FILETIME>();\n  final pUserTime = calloc<FILETIME>();\n  final pCreationSystemTime = calloc<SYSTEMTIME>();\n\n  try {\n    // Retrieve timing information for the current process\n    var hr = GetProcessTimes(\n        hProcess, pCreationTime, pExitTime, pKernelTime, pUserTime);\n    if (FAILED(hr)) throw WindowsException(hr);\n\n    // Convert to UTC\n    hr = FileTimeToSystemTime(pCreationTime, pCreationSystemTime);\n    if (FAILED(hr)) throw WindowsException(hr);\n    return DateTime.utc(\n            pCreationSystemTime.ref.wYear,\n            pCreationSystemTime.ref.wMonth,\n            pCreationSystemTime.ref.wDay,\n            pCreationSystemTime.ref.wHour,\n            pCreationSystemTime.ref.wMinute,\n            pCreationSystemTime.ref.wSecond)\n        .toLocal();\n  } finally {\n    free(pCreationTime);\n    free(pExitTime);\n    free(pKernelTime);\n    free(pUserTime);\n    free(pCreationSystemTime);\n  }\n}\n")),(0,r.kt)("p",null,"There are two problems with this code. Firstly, each variable has to be\nindividually freed. Secondly, the variable ",(0,r.kt)("inlineCode",{parentName:"p"},"pCreationSystemTime")," has to be\nallocated even if the first call fails. This can be a nuisance in larger\nmethods."),(0,r.kt)("p",null,"An alternative approach is to use the ",(0,r.kt)("inlineCode",{parentName:"p"},"using")," pattern with an ",(0,r.kt)("inlineCode",{parentName:"p"},"Arena")," object,\nwhich is a memory allocator that tracks memory allocations and automatically\nreleases them when the ",(0,r.kt)("inlineCode",{parentName:"p"},"using")," scope ends."),(0,r.kt)("p",null,"Here's the same function written this way:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-dart"},"DateTime processCreationTime() {\n  return using((Arena alloc) {\n    final hProcess = GetCurrentProcess();\n    final pCreationTime = alloc<FILETIME>();\n    final pExitTime = alloc<FILETIME>();\n    final pKernelTime = alloc<FILETIME>();\n    final pUserTime = alloc<FILETIME>();\n\n    // Retrieve timing information for the current process\n    var hr = GetProcessTimes(\n        hProcess, pCreationTime, pExitTime, pKernelTime, pUserTime);\n    if (FAILED(hr)) throw WindowsException(hr);\n\n    // Convert to UTC\n    final pCreationSystemTime = alloc<SYSTEMTIME>();\n    hr = FileTimeToSystemTime(pCreationTime, pCreationSystemTime);\n    if (FAILED(hr)) throw WindowsException(hr);\n    return DateTime.utc(\n            pCreationSystemTime.ref.wYear,\n            pCreationSystemTime.ref.wMonth,\n            pCreationSystemTime.ref.wDay,\n            pCreationSystemTime.ref.wHour,\n            pCreationSystemTime.ref.wMinute,\n            pCreationSystemTime.ref.wSecond)\n        .toLocal();\n  });\n}\n")),(0,r.kt)("p",null,"In the above code, the need for individual ",(0,r.kt)("inlineCode",{parentName:"p"},"free")," calls is dispensed with. When\nthe ",(0,r.kt)("inlineCode",{parentName:"p"},"using")," scope ends, the arena releases all the variables that have been\nallocated. Arenas can also be nested or shared across functions, which can be\nuseful when you need greater control over the lifetime of manually-allocated\nmemory."),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("p",{parentName:"admonition"},"The ",(0,r.kt)("inlineCode",{parentName:"p"},".toNativeUtf16()")," String extension method supports passing a custom\nallocator, so it can also be used with arenas. For example:"),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-dart"},"final pTitle = 'Window title'.toNativeUtf16(allocator: alloc);\n"))))}d.isMDXComponent=!0}}]);